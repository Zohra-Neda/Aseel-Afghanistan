/*!
  * Bootstrap v5.3.0-alpha3 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e(require('@popperjs/core')) : typeof define === 'function' && define.amd ? define(['@popperjs/core'], e) : (t = typeof globalThis !== 'undefined' ? globalThis : t || self).bootstrap = e(t.Popper); }(this, ((t) => {
  function e(t) { const e = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } }); if (t) for (const s in t) if (s !== 'default') { const i = Object.getOwnPropertyDescriptor(t, s); Object.defineProperty(e, s, i.get ? i : { enumerable: !0, get: () => t[s] }); } return e.default = t, Object.freeze(e); } const s = e(t); const i = new Map(); const n = { set(t, e, s) { i.has(t) || i.set(t, new Map()); const n = i.get(t); n.has(e) || n.size === 0 ? n.set(e, s) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`); }, get: (t, e) => i.has(t) && i.get(t).get(e) || null, remove(t, e) { if (!i.has(t)) return; const s = i.get(t); s.delete(e), s.size === 0 && i.delete(t); } }; const o = 'transitionend'; const r = (t) => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t); const a = (t) => { t.dispatchEvent(new Event(o)); }; const l = (t) => !(!t || typeof t !== 'object') && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType); const c = (t) => (l(t) ? t.jquery ? t[0] : t : typeof t === 'string' && t.length > 0 ? document.querySelector(r(t)) : null); const h = (t) => { if (!l(t) || t.getClientRects().length === 0) return !1; const e = getComputedStyle(t).getPropertyValue('visibility') === 'visible'; const s = t.closest('details:not([open])'); if (!s) return e; if (s !== t) { const e = t.closest('summary'); if (e && e.parentNode !== s) return !1; if (e === null) return !1; } return e; }; const d = (t) => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains('disabled') || (void 0 !== t.disabled ? t.disabled : t.hasAttribute('disabled') && t.getAttribute('disabled') !== 'false'); const u = (t) => { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode === 'function') { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null; } return t instanceof ShadowRoot ? t : t.parentNode ? u(t.parentNode) : null; }; const _ = () => {}; const g = (t) => { t.offsetHeight; }; const f = () => (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null); const m = []; const p = () => document.documentElement.dir === 'rtl'; const b = (t) => { let e; e = () => { const e = f(); if (e) { const s = t.NAME; const i = e.fn[s]; e.fn[s] = t.jQueryInterface, e.fn[s].Constructor = t, e.fn[s].noConflict = () => (e.fn[s] = i, t.jQueryInterface); } }, document.readyState === 'loading' ? (m.length || document.addEventListener('DOMContentLoaded', (() => { for (const t of m)t(); })), m.push(e)) : e(); }; const v = (t, e = [], s = t) => (typeof t === 'function' ? t(...e) : s); const y = (t, e, s = !0) => { if (!s) return void v(t); const i = ((t) => { if (!t) return 0; let{ transitionDuration: e, transitionDelay: s } = window.getComputedStyle(t); const i = Number.parseFloat(e); const n = Number.parseFloat(s); return i || n ? (e = e.split(',')[0], s = s.split(',')[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(s))) : 0; })(e) + 5; let n = !1; const r = ({ target: s }) => { s === e && (n = !0, e.removeEventListener(o, r), v(t)); }; e.addEventListener(o, r), setTimeout((() => { n || a(e); }), i); }; const w = (t, e, s, i) => { const n = t.length; let o = t.indexOf(e); return o === -1 ? !s && i ? t[n - 1] : t[0] : (o += s ? 1 : -1, i && (o = (o + n) % n), t[Math.max(0, Math.min(o, n - 1))]); }; const A = /[^.]*(?=\..*)\.|.*/; const E = /\..*/; const C = /::\d+$/; const T = {}; let k = 1; const S = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const L = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function O(t, e) { return e && `${e}::${k++}` || t.uidEvent || k++; } function I(t) { const e = O(t); return t.uidEvent = e, T[e] = T[e] || {}, T[e]; } function D(t, e, s = null) { return Object.values(t).find(((t) => t.callable === e && t.delegationSelector === s)); } function N(t, e, s) { const i = typeof e === 'string'; const n = i ? s : e || s; let o = j(t); return L.has(o) || (o = t), [i, n, o]; } function P(t, e, s, i, n) { if (typeof e !== 'string' || !t) return; let[o, r, a] = N(e, s, i); if (e in S) { const t = (t) => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e); }; r = t(r); } const l = I(t); const c = l[a] || (l[a] = {}); const h = D(c, r, o ? s : null); if (h) return void (h.oneOff = h.oneOff && n); const d = O(r, e.replace(A, '')); const u = o ? (function (t, e, s) { return function i(n) { const o = t.querySelectorAll(e); for (let{ target: r } = n; r && r !== this; r = r.parentNode) for (const a of o) if (a === r) return $(n, { delegateTarget: r }), i.oneOff && F.off(t, n.type, e, s), s.apply(r, [n]); }; }(t, s, r)) : (function (t, e) { return function s(i) { return $(i, { delegateTarget: t }), s.oneOff && F.off(t, i.type, e), e.apply(t, [i]); }; }(t, r)); u.delegationSelector = o ? s : null, u.callable = r, u.oneOff = n, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o); } function x(t, e, s, i, n) { const o = D(e[s], i, n); o && (t.removeEventListener(s, o, Boolean(n)), delete e[s][o.uidEvent]); } function M(t, e, s, i) { const n = e[s] || {}; for (const [o, r] of Object.entries(n))o.includes(i) && x(t, e, s, r.callable, r.delegationSelector); } function j(t) { return t = t.replace(E, ''), S[t] || t; } const F = {
    on(t, e, s, i) { P(t, e, s, i, !1); }, one(t, e, s, i) { P(t, e, s, i, !0); }, off(t, e, s, i) { if (typeof e !== 'string' || !t) return; const [n, o, r] = N(e, s, i); const a = r !== e; const l = I(t); const c = l[r] || {}; const h = e.startsWith('.'); if (void 0 === o) { if (h) for (const s of Object.keys(l))M(t, l, s, e.slice(1)); for (const [s, i] of Object.entries(c)) { const n = s.replace(C, ''); a && !e.includes(n) || x(t, l, r, i.callable, i.delegationSelector); } } else { if (!Object.keys(c).length) return; x(t, l, r, o, n ? s : null); } }, trigger(t, e, s) { if (typeof e !== 'string' || !t) return null; const i = f(); let n = null; let o = !0; let r = !0; let a = !1; e !== j(e) && i && (n = i.Event(e, s), i(t).trigger(n), o = !n.isPropagationStopped(), r = !n.isImmediatePropagationStopped(), a = n.isDefaultPrevented()); const l = $(new Event(e, { bubbles: o, cancelable: !0 }), s); return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && n && n.preventDefault(), l; },
  }; function $(t, e = {}) { for (const [s, i] of Object.entries(e)) try { t[s] = i; } catch (e) { Object.defineProperty(t, s, { configurable: !0, get: () => i }); } return t; } function z(t) { if (t === 'true') return !0; if (t === 'false') return !1; if (t === Number(t).toString()) return Number(t); if (t === '' || t === 'null') return null; if (typeof t !== 'string') return t; try { return JSON.parse(decodeURIComponent(t)); } catch (e) { return t; } } function H(t) { return t.replace(/[A-Z]/g, ((t) => `-${t.toLowerCase()}`)); } const B = {
    setDataAttribute(t, e, s) { t.setAttribute(`data-bs-${H(e)}`, s); }, removeDataAttribute(t, e) { t.removeAttribute(`data-bs-${H(e)}`); }, getDataAttributes(t) { if (!t) return {}; const e = {}; const s = Object.keys(t.dataset).filter(((t) => t.startsWith('bs') && !t.startsWith('bsConfig'))); for (const i of s) { let s = i.replace(/^bs/, ''); s = s.charAt(0).toLowerCase() + s.slice(1, s.length), e[s] = z(t.dataset[i]); } return e; }, getDataAttribute: (t, e) => z(t.getAttribute(`data-bs-${H(e)}`)),
  }; class q {
    static get Default() { return {}; }

    static get DefaultType() { return {}; }

    static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!'); }

    _getConfig(t) { return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t; }

    _configAfterMerge(t) { return t; }

    _mergeConfigObj(t, e) {
      const s = l(e) ? B.getDataAttribute(e, 'config') : {}; return {
        ...this.constructor.Default, ...typeof s === 'object' ? s : {}, ...l(e) ? B.getDataAttributes(e) : {}, ...typeof t === 'object' ? t : {},
      };
    }

    _typeCheckConfig(t, e = this.constructor.DefaultType) { for (const [i, n] of Object.entries(e)) { const e = t[i]; const o = l(e) ? 'element' : (s = e) == null ? `${s}` : Object.prototype.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${o}" but expected type "${n}".`); } let s; }
  } class W extends q {
    constructor(t, e) { super(), (t = c(t)) && (this._element = t, this._config = this._getConfig(e), n.set(this._element, this.constructor.DATA_KEY, this)); }

    dispose() { n.remove(this._element, this.constructor.DATA_KEY), F.off(this._element, this.constructor.EVENT_KEY); for (const t of Object.getOwnPropertyNames(this)) this[t] = null; }

    _queueCallback(t, e, s = !0) { y(t, e, s); }

    _getConfig(t) { return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t; }

    static getInstance(t) { return n.get(c(t), this.DATA_KEY); }

    static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, typeof e === 'object' ? e : null); }

    static get VERSION() { return '5.3.0-alpha2'; }

    static get DATA_KEY() { return `bs.${this.NAME}`; }

    static get EVENT_KEY() { return `.${this.DATA_KEY}`; }

    static eventName(t) { return `${t}${this.EVENT_KEY}`; }
  } const R = (t) => { let e = t.getAttribute('data-bs-target'); if (!e || e === '#') { let s = t.getAttribute('href'); if (!s || !s.includes('#') && !s.startsWith('.')) return null; s.includes('#') && !s.startsWith('#') && (s = `#${s.split('#')[1]}`), e = s && s !== '#' ? s.trim() : null; } return r(e); }; const V = {
    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)), findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t), children: (t, e) => [].concat(...t.children).filter(((t) => t.matches(e))), parents(t, e) { const s = []; let i = t.parentNode.closest(e); for (;i;)s.push(i), i = i.parentNode.closest(e); return s; }, prev(t, e) { let s = t.previousElementSibling; for (;s;) { if (s.matches(e)) return [s]; s = s.previousElementSibling; } return []; }, next(t, e) { let s = t.nextElementSibling; for (;s;) { if (s.matches(e)) return [s]; s = s.nextElementSibling; } return []; }, focusableChildren(t) { const e = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(((t) => `${t}:not([tabindex^="-"])`)).join(','); return this.find(e, t).filter(((t) => !d(t) && h(t))); }, getSelectorFromElement(t) { const e = R(t); return e && V.findOne(e) ? e : null; }, getElementFromSelector(t) { const e = R(t); return e ? V.findOne(e) : null; }, getMultipleElementsFromSelector(t) { const e = R(t); return e ? V.find(e) : []; },
  }; const K = (t, e = 'hide') => { const s = `click.dismiss${t.EVENT_KEY}`; const i = t.NAME; F.on(document, s, `[data-bs-dismiss="${i}"]`, (function (s) { if (['A', 'AREA'].includes(this.tagName) && s.preventDefault(), d(this)) return; const n = V.getElementFromSelector(this) || this.closest(`.${i}`); t.getOrCreateInstance(n)[e](); })); }; class Q extends W {
    static get NAME() { return 'alert'; }

    close() { if (F.trigger(this._element, 'close.bs.alert').defaultPrevented) return; this._element.classList.remove('show'); const t = this._element.classList.contains('fade'); this._queueCallback((() => this._destroyElement()), this._element, t); }

    _destroyElement() { this._element.remove(), F.trigger(this._element, 'closed.bs.alert'), this.dispose(); }

    static jQueryInterface(t) { return this.each((function () { const e = Q.getOrCreateInstance(this); if (typeof t === 'string') { if (void 0 === e[t] || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  }K(Q, 'close'), b(Q); const X = '[data-bs-toggle="button"]'; class Y extends W {
    static get NAME() { return 'button'; }

    toggle() { this._element.setAttribute('aria-pressed', this._element.classList.toggle('active')); }

    static jQueryInterface(t) { return this.each((function () { const e = Y.getOrCreateInstance(this); t === 'toggle' && e[t](); })); }
  }F.on(document, 'click.bs.button.data-api', X, ((t) => { t.preventDefault(); const e = t.target.closest(X); Y.getOrCreateInstance(e).toggle(); })), b(Y); const U = { endCallback: null, leftCallback: null, rightCallback: null }; const G = { endCallback: '(function|null)', leftCallback: '(function|null)', rightCallback: '(function|null)' }; class J extends q {
    constructor(t, e) { super(), this._element = t, t && J.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()); }

    static get Default() { return U; }

    static get DefaultType() { return G; }

    static get NAME() { return 'swipe'; }

    dispose() { F.off(this._element, '.bs.swipe'); }

    _start(t) { this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX; }

    _end(t) { this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), v(this._config.endCallback); }

    _move(t) { this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX; }

    _handleSwipe() { const t = Math.abs(this._deltaX); if (t <= 40) return; const e = t / this._deltaX; this._deltaX = 0, e && v(e > 0 ? this._config.rightCallback : this._config.leftCallback); }

    _initEvents() { this._supportPointerEvents ? (F.on(this._element, 'pointerdown.bs.swipe', ((t) => this._start(t))), F.on(this._element, 'pointerup.bs.swipe', ((t) => this._end(t))), this._element.classList.add('pointer-event')) : (F.on(this._element, 'touchstart.bs.swipe', ((t) => this._start(t))), F.on(this._element, 'touchmove.bs.swipe', ((t) => this._move(t))), F.on(this._element, 'touchend.bs.swipe', ((t) => this._end(t)))); }

    _eventIsPointerPenTouch(t) { return this._supportPointerEvents && (t.pointerType === 'pen' || t.pointerType === 'touch'); }

    static isSupported() { return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0; }
  } const Z = 'next'; const tt = 'prev'; const et = 'left'; const st = 'right'; const it = 'slid.bs.carousel'; const nt = 'carousel'; const ot = 'active'; const rt = { ArrowLeft: st, ArrowRight: et }; const at = {
    interval: 5e3, keyboard: !0, pause: 'hover', ride: !1, touch: !0, wrap: !0,
  }; const lt = {
    interval: '(number|boolean)', keyboard: 'boolean', pause: '(string|boolean)', ride: '(boolean|string)', touch: 'boolean', wrap: 'boolean',
  }; class ct extends W {
    constructor(t, e) { super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = V.findOne('.carousel-indicators', this._element), this._addEventListeners(), this._config.ride === nt && this.cycle(); }

    static get Default() { return at; }

    static get DefaultType() { return lt; }

    static get NAME() { return 'carousel'; }

    next() { this._slide(Z); }

    nextWhenVisible() { !document.hidden && h(this._element) && this.next(); }

    prev() { this._slide(tt); }

    pause() { this._isSliding && a(this._element), this._clearInterval(); }

    cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval); }

    _maybeEnableCycle() { this._config.ride && (this._isSliding ? F.one(this._element, it, (() => this.cycle())) : this.cycle()); }

    to(t) { const e = this._getItems(); if (t > e.length - 1 || t < 0) return; if (this._isSliding) return void F.one(this._element, it, (() => this.to(t))); const s = this._getItemIndex(this._getActive()); if (s === t) return; const i = t > s ? Z : tt; this._slide(i, e[t]); }

    dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose(); }

    _configAfterMerge(t) { return t.defaultInterval = t.interval, t; }

    _addEventListeners() { this._config.keyboard && F.on(this._element, 'keydown.bs.carousel', ((t) => this._keydown(t))), this._config.pause === 'hover' && (F.on(this._element, 'mouseenter.bs.carousel', (() => this.pause())), F.on(this._element, 'mouseleave.bs.carousel', (() => this._maybeEnableCycle()))), this._config.touch && J.isSupported() && this._addTouchEventListeners(); }

    _addTouchEventListeners() { for (const t of V.find('.carousel-item img', this._element))F.on(t, 'dragstart.bs.carousel', ((t) => t.preventDefault())); const t = { leftCallback: () => this._slide(this._directionToOrder(et)), rightCallback: () => this._slide(this._directionToOrder(st)), endCallback: () => { this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval)); } }; this._swipeHelper = new J(this._element, t); }

    _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = rt[t.key]; e && (t.preventDefault(), this._slide(this._directionToOrder(e))); }

    _getItemIndex(t) { return this._getItems().indexOf(t); }

    _setActiveIndicatorElement(t) { if (!this._indicatorsElement) return; const e = V.findOne('.active', this._indicatorsElement); e.classList.remove(ot), e.removeAttribute('aria-current'); const s = V.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement); s && (s.classList.add(ot), s.setAttribute('aria-current', 'true')); }

    _updateInterval() { const t = this._activeElement || this._getActive(); if (!t) return; const e = Number.parseInt(t.getAttribute('data-bs-interval'), 10); this._config.interval = e || this._config.defaultInterval; }

    _slide(t, e = null) {
      if (this._isSliding) return; const s = this._getActive(); const i = t === Z; const n = e || w(this._getItems(), s, i, this._config.wrap); if (n === s) return; const o = this._getItemIndex(n); const r = (e) => F.trigger(this._element, e, {
        relatedTarget: n, direction: this._orderToDirection(t), from: this._getItemIndex(s), to: o,
      }); if (r('slide.bs.carousel').defaultPrevented) return; if (!s || !n) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = n; const l = i ? 'carousel-item-start' : 'carousel-item-end'; const c = i ? 'carousel-item-next' : 'carousel-item-prev'; n.classList.add(c), g(n), s.classList.add(l), n.classList.add(l), this._queueCallback((() => { n.classList.remove(l, c), n.classList.add(ot), s.classList.remove(ot, c, l), this._isSliding = !1, r(it); }), s, this._isAnimated()), a && this.cycle();
    }

    _isAnimated() { return this._element.classList.contains('slide'); }

    _getActive() { return V.findOne('.active.carousel-item', this._element); }

    _getItems() { return V.find('.carousel-item', this._element); }

    _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null); }

    _directionToOrder(t) { return p() ? t === et ? tt : Z : t === et ? Z : tt; }

    _orderToDirection(t) { return p() ? t === tt ? et : st : t === tt ? st : et; }

    static jQueryInterface(t) { return this.each((function () { const e = ct.getOrCreateInstance(this, t); if (typeof t !== 'number') { if (typeof t === 'string') { if (void 0 === e[t] || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](); } } else e.to(t); })); }
  }F.on(document, 'click.bs.carousel.data-api', '[data-bs-slide], [data-bs-slide-to]', (function (t) { const e = V.getElementFromSelector(this); if (!e || !e.classList.contains(nt)) return; t.preventDefault(); const s = ct.getOrCreateInstance(e); const i = this.getAttribute('data-bs-slide-to'); return i ? (s.to(i), void s._maybeEnableCycle()) : B.getDataAttribute(this, 'slide') === 'next' ? (s.next(), void s._maybeEnableCycle()) : (s.prev(), void s._maybeEnableCycle()); })), F.on(window, 'load.bs.carousel.data-api', (() => { const t = V.find('[data-bs-ride="carousel"]'); for (const e of t)ct.getOrCreateInstance(e); })), b(ct); const ht = 'show'; const dt = 'collapse'; const ut = 'collapsing'; const _t = '[data-bs-toggle="collapse"]'; const gt = { parent: null, toggle: !0 }; const ft = { parent: '(null|element)', toggle: 'boolean' }; class mt extends W {
    constructor(t, e) { super(t, e), this._isTransitioning = !1, this._triggerArray = []; const s = V.find(_t); for (const t of s) { const e = V.getSelectorFromElement(t); const s = V.find(e).filter(((t) => t === this._element)); e !== null && s.length && this._triggerArray.push(t); } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle(); }

    static get Default() { return gt; }

    static get DefaultType() { return ft; }

    static get NAME() { return 'collapse'; }

    toggle() { this._isShown() ? this.hide() : this.show(); }

    show() { if (this._isTransitioning || this._isShown()) return; let t = []; if (this._config.parent && (t = this._getFirstLevelChildren('.collapse.show, .collapse.collapsing').filter(((t) => t !== this._element)).map(((t) => mt.getOrCreateInstance(t, { toggle: !1 })))), t.length && t[0]._isTransitioning) return; if (F.trigger(this._element, 'show.bs.collapse').defaultPrevented) return; for (const e of t)e.hide(); const e = this._getDimension(); this._element.classList.remove(dt), this._element.classList.add(ut), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const s = `scroll${e[0].toUpperCase() + e.slice(1)}`; this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(ut), this._element.classList.add(dt, ht), this._element.style[e] = '', F.trigger(this._element, 'shown.bs.collapse'); }), this._element, !0), this._element.style[e] = `${this._element[s]}px`; }

    hide() { if (this._isTransitioning || !this._isShown()) return; if (F.trigger(this._element, 'hide.bs.collapse').defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, g(this._element), this._element.classList.add(ut), this._element.classList.remove(dt, ht); for (const t of this._triggerArray) { const e = V.getElementFromSelector(t); e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1); } this._isTransitioning = !0, this._element.style[t] = '', this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(ut), this._element.classList.add(dt), F.trigger(this._element, 'hidden.bs.collapse'); }), this._element, !0); }

    _isShown(t = this._element) { return t.classList.contains(ht); }

    _configAfterMerge(t) { return t.toggle = Boolean(t.toggle), t.parent = c(t.parent), t; }

    _getDimension() { return this._element.classList.contains('collapse-horizontal') ? 'width' : 'height'; }

    _initializeChildren() { if (!this._config.parent) return; const t = this._getFirstLevelChildren(_t); for (const e of t) { const t = V.getElementFromSelector(e); t && this._addAriaAndCollapsedClass([e], this._isShown(t)); } }

    _getFirstLevelChildren(t) { const e = V.find(':scope .collapse .collapse', this._config.parent); return V.find(t, this._config.parent).filter(((t) => !e.includes(t))); }

    _addAriaAndCollapsedClass(t, e) { if (t.length) for (const s of t)s.classList.toggle('collapsed', !e), s.setAttribute('aria-expanded', e); }

    static jQueryInterface(t) { const e = {}; return typeof t === 'string' && /show|hide/.test(t) && (e.toggle = !1), this.each((function () { const s = mt.getOrCreateInstance(this, e); if (typeof t === 'string') { if (void 0 === s[t]) throw new TypeError(`No method named "${t}"`); s[t](); } })); }
  }F.on(document, 'click.bs.collapse.data-api', _t, (function (t) { (t.target.tagName === 'A' || t.delegateTarget && t.delegateTarget.tagName === 'A') && t.preventDefault(); for (const t of V.getMultipleElementsFromSelector(this))mt.getOrCreateInstance(t, { toggle: !1 }).toggle(); })), b(mt); const pt = 'dropdown'; const bt = 'ArrowUp'; const vt = 'ArrowDown'; const yt = 'click.bs.dropdown.data-api'; const wt = 'keydown.bs.dropdown.data-api'; const At = 'show'; const Et = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'; const Ct = `${Et}.show`; const Tt = '.dropdown-menu'; const kt = p() ? 'top-end' : 'top-start'; const St = p() ? 'top-start' : 'top-end'; const Lt = p() ? 'bottom-end' : 'bottom-start'; const Ot = p() ? 'bottom-start' : 'bottom-end'; const It = p() ? 'left-start' : 'right-start'; const Dt = p() ? 'right-start' : 'left-start'; const Nt = {
    autoClose: !0, boundary: 'clippingParents', display: 'dynamic', offset: [0, 2], popperConfig: null, reference: 'toggle',
  }; const Pt = {
    autoClose: '(boolean|string)', boundary: '(string|element)', display: 'string', offset: '(array|string|function)', popperConfig: '(null|object|function)', reference: '(string|element|object)',
  }; class xt extends W {
    constructor(t, e) { super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = V.next(this._element, Tt)[0] || V.prev(this._element, Tt)[0] || V.findOne(Tt, this._parent), this._inNavbar = this._detectNavbar(); }

    static get Default() { return Nt; }

    static get DefaultType() { return Pt; }

    static get NAME() { return pt; }

    toggle() { return this._isShown() ? this.hide() : this.show(); }

    show() { if (d(this._element) || this._isShown()) return; const t = { relatedTarget: this._element }; if (!F.trigger(this._element, 'show.bs.dropdown', t).defaultPrevented) { if (this._createPopper(), 'ontouchstart' in document.documentElement && !this._parent.closest('.navbar-nav')) for (const t of [].concat(...document.body.children))F.on(t, 'mouseover', _); this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add(At), this._element.classList.add(At), F.trigger(this._element, 'shown.bs.dropdown', t); } }

    hide() { if (d(this._element) || !this._isShown()) return; const t = { relatedTarget: this._element }; this._completeHide(t); }

    dispose() { this._popper && this._popper.destroy(), super.dispose(); }

    update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update(); }

    _completeHide(t) { if (!F.trigger(this._element, 'hide.bs.dropdown', t).defaultPrevented) { if ('ontouchstart' in document.documentElement) for (const t of [].concat(...document.body.children))F.off(t, 'mouseover', _); this._popper && this._popper.destroy(), this._menu.classList.remove(At), this._element.classList.remove(At), this._element.setAttribute('aria-expanded', 'false'), B.removeDataAttribute(this._menu, 'popper'), F.trigger(this._element, 'hidden.bs.dropdown', t); } }

    _getConfig(t) { if (typeof (t = super._getConfig(t)).reference === 'object' && !l(t.reference) && typeof t.reference.getBoundingClientRect !== 'function') throw new TypeError(`${pt.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t; }

    _createPopper() { if (void 0 === s) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; this._config.reference === 'parent' ? t = this._parent : l(this._config.reference) ? t = c(this._config.reference) : typeof this._config.reference === 'object' && (t = this._config.reference); const e = this._getPopperConfig(); this._popper = s.createPopper(t, this._menu, e); }

    _isShown() { return this._menu.classList.contains(At); }

    _getPlacement() { const t = this._parent; if (t.classList.contains('dropend')) return It; if (t.classList.contains('dropstart')) return Dt; if (t.classList.contains('dropup-center')) return 'top'; if (t.classList.contains('dropdown-center')) return 'bottom'; const e = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return t.classList.contains('dropup') ? e ? St : kt : e ? Ot : Lt; }

    _detectNavbar() { return this._element.closest('.navbar') !== null; }

    _getOffset() { const { offset: t } = this._config; return typeof t === 'string' ? t.split(',').map(((t) => Number.parseInt(t, 10))) : typeof t === 'function' ? (e) => t(e, this._element) : t; }

    _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === 'static') && (B.setDataAttribute(this._menu, 'popper', 'static'), t.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...t, ...v(this._config.popperConfig, [t]) }; }

    _selectMenuItem({ key: t, target: e }) { const s = V.find('.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', this._menu).filter(((t) => h(t))); s.length && w(s, e, t === vt, !s.includes(e)).focus(); }

    static jQueryInterface(t) { return this.each((function () { const e = xt.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }

    static clearMenus(t) { if (t.button === 2 || t.type === 'keyup' && t.key !== 'Tab') return; const e = V.find(Ct); for (const s of e) { const e = xt.getInstance(s); if (!e || !1 === e._config.autoClose) continue; const i = t.composedPath(); const n = i.includes(e._menu); if (i.includes(e._element) || e._config.autoClose === 'inside' && !n || e._config.autoClose === 'outside' && n) continue; if (e._menu.contains(t.target) && (t.type === 'keyup' && t.key === 'Tab' || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; const o = { relatedTarget: e._element }; t.type === 'click' && (o.clickEvent = t), e._completeHide(o); } }

    static dataApiKeydownHandler(t) { const e = /input|textarea/i.test(t.target.tagName); const s = t.key === 'Escape'; const i = [bt, vt].includes(t.key); if (!i && !s) return; if (e && !s) return; t.preventDefault(); const n = this.matches(Et) ? this : V.prev(this, Et)[0] || V.next(this, Et)[0] || V.findOne(Et, t.delegateTarget.parentNode); const o = xt.getOrCreateInstance(n); if (i) return t.stopPropagation(), o.show(), void o._selectMenuItem(t); o._isShown() && (t.stopPropagation(), o.hide(), n.focus()); }
  }F.on(document, wt, Et, xt.dataApiKeydownHandler), F.on(document, wt, Tt, xt.dataApiKeydownHandler), F.on(document, yt, xt.clearMenus), F.on(document, 'keyup.bs.dropdown.data-api', xt.clearMenus), F.on(document, yt, Et, (function (t) { t.preventDefault(), xt.getOrCreateInstance(this).toggle(); })), b(xt); const Mt = 'show'; const jt = 'mousedown.bs.backdrop'; const Ft = {
    className: 'modal-backdrop', clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: 'body',
  }; const $t = {
    className: 'string', clickCallback: '(function|null)', isAnimated: 'boolean', isVisible: 'boolean', rootElement: '(element|string)',
  }; class zt extends q {
    constructor(t) { super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null; }

    static get Default() { return Ft; }

    static get DefaultType() { return $t; }

    static get NAME() { return 'backdrop'; }

    show(t) { if (!this._config.isVisible) return void v(t); this._append(); const e = this._getElement(); this._config.isAnimated && g(e), e.classList.add(Mt), this._emulateAnimation((() => { v(t); })); }

    hide(t) { this._config.isVisible ? (this._getElement().classList.remove(Mt), this._emulateAnimation((() => { this.dispose(), v(t); }))) : v(t); }

    dispose() { this._isAppended && (F.off(this._element, jt), this._element.remove(), this._isAppended = !1); }

    _getElement() { if (!this._element) { const t = document.createElement('div'); t.className = this._config.className, this._config.isAnimated && t.classList.add('fade'), this._element = t; } return this._element; }

    _configAfterMerge(t) { return t.rootElement = c(t.rootElement), t; }

    _append() { if (this._isAppended) return; const t = this._getElement(); this._config.rootElement.append(t), F.on(t, jt, (() => { v(this._config.clickCallback); })), this._isAppended = !0; }

    _emulateAnimation(t) { y(t, this._getElement(), this._config.isAnimated); }
  } const Ht = '.bs.focustrap'; const Bt = 'backward'; const qt = { autofocus: !0, trapElement: null }; const Wt = { autofocus: 'boolean', trapElement: 'element' }; class Rt extends q {
    constructor(t) { super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null; }

    static get Default() { return qt; }

    static get DefaultType() { return Wt; }

    static get NAME() { return 'focustrap'; }

    activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), F.off(document, Ht), F.on(document, 'focusin.bs.focustrap', ((t) => this._handleFocusin(t))), F.on(document, 'keydown.tab.bs.focustrap', ((t) => this._handleKeydown(t))), this._isActive = !0); }

    deactivate() { this._isActive && (this._isActive = !1, F.off(document, Ht)); }

    _handleFocusin(t) { const { trapElement: e } = this._config; if (t.target === document || t.target === e || e.contains(t.target)) return; const s = V.focusableChildren(e); s.length === 0 ? e.focus() : this._lastTabNavDirection === Bt ? s[s.length - 1].focus() : s[0].focus(); }

    _handleKeydown(t) { t.key === 'Tab' && (this._lastTabNavDirection = t.shiftKey ? Bt : 'forward'); }
  } const Vt = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const Kt = '.sticky-top'; const Qt = 'padding-right'; const Xt = 'margin-right'; class Yt {
    constructor() { this._element = document.body; }

    getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t); }

    hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Qt, ((e) => e + t)), this._setElementAttributes(Vt, Qt, ((e) => e + t)), this._setElementAttributes(Kt, Xt, ((e) => e - t)); }

    reset() { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, Qt), this._resetElementAttributes(Vt, Qt), this._resetElementAttributes(Kt, Xt); }

    isOverflowing() { return this.getWidth() > 0; }

    _disableOverFlow() { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden'; }

    _setElementAttributes(t, e, s) { const i = this.getWidth(); this._applyManipulationCallback(t, ((t) => { if (t !== this._element && window.innerWidth > t.clientWidth + i) return; this._saveInitialAttribute(t, e); const n = window.getComputedStyle(t).getPropertyValue(e); t.style.setProperty(e, `${s(Number.parseFloat(n))}px`); })); }

    _saveInitialAttribute(t, e) { const s = t.style.getPropertyValue(e); s && B.setDataAttribute(t, e, s); }

    _resetElementAttributes(t, e) { this._applyManipulationCallback(t, ((t) => { const s = B.getDataAttribute(t, e); s !== null ? (B.removeDataAttribute(t, e), t.style.setProperty(e, s)) : t.style.removeProperty(e); })); }

    _applyManipulationCallback(t, e) { if (l(t))e(t); else for (const s of V.find(t, this._element))e(s); }
  } const Ut = '.bs.modal'; const Gt = 'hidden.bs.modal'; const Jt = 'show.bs.modal'; const Zt = 'modal-open'; const te = 'show'; const ee = 'modal-static'; const se = { backdrop: !0, focus: !0, keyboard: !0 }; const ie = { backdrop: '(boolean|string)', focus: 'boolean', keyboard: 'boolean' }; class ne extends W {
    constructor(t, e) { super(t, e), this._dialog = V.findOne('.modal-dialog', this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Yt(), this._addEventListeners(); }

    static get Default() { return se; }

    static get DefaultType() { return ie; }

    static get NAME() { return 'modal'; }

    toggle(t) { return this._isShown ? this.hide() : this.show(t); }

    show(t) { this._isShown || this._isTransitioning || F.trigger(this._element, Jt, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Zt), this._adjustDialog(), this._backdrop.show((() => this._showElement(t)))); }

    hide() { this._isShown && !this._isTransitioning && (F.trigger(this._element, 'hide.bs.modal').defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(te), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated()))); }

    dispose() { F.off(window, Ut), F.off(this._dialog, Ut), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }

    handleUpdate() { this._adjustDialog(); }

    _initializeBackDrop() { return new zt({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }); }

    _initializeFocusTrap() { return new Rt({ trapElement: this._element }); }

    _showElement(t) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0; const e = V.findOne('.modal-body', this._dialog); e && (e.scrollTop = 0), g(this._element), this._element.classList.add(te), this._queueCallback((() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, F.trigger(this._element, 'shown.bs.modal', { relatedTarget: t }); }), this._dialog, this._isAnimated()); }

    _addEventListeners() { F.on(this._element, 'keydown.dismiss.bs.modal', ((t) => { t.key === 'Escape' && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition()); })), F.on(window, 'resize.bs.modal', (() => { this._isShown && !this._isTransitioning && this._adjustDialog(); })), F.on(this._element, 'mousedown.dismiss.bs.modal', ((t) => { F.one(this._element, 'click.dismiss.bs.modal', ((e) => { this._element === t.target && this._element === e.target && (this._config.backdrop !== 'static' ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()); })); })); }

    _hideModal() { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide((() => { document.body.classList.remove(Zt), this._resetAdjustments(), this._scrollBar.reset(), F.trigger(this._element, Gt); })); }

    _isAnimated() { return this._element.classList.contains('fade'); }

    _triggerBackdropTransition() { if (F.trigger(this._element, 'hidePrevented.bs.modal').defaultPrevented) return; const t = this._element.scrollHeight > document.documentElement.clientHeight; const e = this._element.style.overflowY; e === 'hidden' || this._element.classList.contains(ee) || (t || (this._element.style.overflowY = 'hidden'), this._element.classList.add(ee), this._queueCallback((() => { this._element.classList.remove(ee), this._queueCallback((() => { this._element.style.overflowY = e; }), this._dialog); }), this._dialog), this._element.focus()); }

    _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight; const e = this._scrollBar.getWidth(); const s = e > 0; if (s && !t) { const t = p() ? 'paddingLeft' : 'paddingRight'; this._element.style[t] = `${e}px`; } if (!s && t) { const t = p() ? 'paddingRight' : 'paddingLeft'; this._element.style[t] = `${e}px`; } }

    _resetAdjustments() { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; }

    static jQueryInterface(t, e) { return this.each((function () { const s = ne.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === s[t]) throw new TypeError(`No method named "${t}"`); s[t](e); } })); }
  }F.on(document, 'click.bs.modal.data-api', '[data-bs-toggle="modal"]', (function (t) { const e = V.getElementFromSelector(this); ['A', 'AREA'].includes(this.tagName) && t.preventDefault(), F.one(e, Jt, ((t) => { t.defaultPrevented || F.one(e, Gt, (() => { h(this) && this.focus(); })); })); const s = V.findOne('.modal.show'); s && ne.getInstance(s).hide(), ne.getOrCreateInstance(e).toggle(this); })), K(ne), b(ne); const oe = 'show'; const re = 'showing'; const ae = 'hiding'; const le = '.offcanvas.show'; const ce = 'hidePrevented.bs.offcanvas'; const he = 'hidden.bs.offcanvas'; const de = { backdrop: !0, keyboard: !0, scroll: !1 }; const ue = { backdrop: '(boolean|string)', keyboard: 'boolean', scroll: 'boolean' }; class _e extends W {
    constructor(t, e) { super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(); }

    static get Default() { return de; }

    static get DefaultType() { return ue; }

    static get NAME() { return 'offcanvas'; }

    toggle(t) { return this._isShown ? this.hide() : this.show(t); }

    show(t) { this._isShown || F.trigger(this._element, 'show.bs.offcanvas', { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Yt()).hide(), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add(re), this._queueCallback((() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(oe), this._element.classList.remove(re), F.trigger(this._element, 'shown.bs.offcanvas', { relatedTarget: t }); }), this._element, !0)); }

    hide() { this._isShown && (F.trigger(this._element, 'hide.bs.offcanvas').defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(ae), this._backdrop.hide(), this._queueCallback((() => { this._element.classList.remove(oe, ae), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._config.scroll || (new Yt()).reset(), F.trigger(this._element, he); }), this._element, !0))); }

    dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }

    _initializeBackDrop() {
      const t = Boolean(this._config.backdrop); return new zt({
        className: 'offcanvas-backdrop', isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? () => { this._config.backdrop !== 'static' ? this.hide() : F.trigger(this._element, ce); } : null,
      });
    }

    _initializeFocusTrap() { return new Rt({ trapElement: this._element }); }

    _addEventListeners() { F.on(this._element, 'keydown.dismiss.bs.offcanvas', ((t) => { t.key === 'Escape' && (this._config.keyboard ? this.hide() : F.trigger(this._element, ce)); })); }

    static jQueryInterface(t) { return this.each((function () { const e = _e.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t] || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  }F.on(document, 'click.bs.offcanvas.data-api', '[data-bs-toggle="offcanvas"]', (function (t) { const e = V.getElementFromSelector(this); if (['A', 'AREA'].includes(this.tagName) && t.preventDefault(), d(this)) return; F.one(e, he, (() => { h(this) && this.focus(); })); const s = V.findOne(le); s && s !== e && _e.getInstance(s).hide(), _e.getOrCreateInstance(e).toggle(this); })), F.on(window, 'load.bs.offcanvas.data-api', (() => { for (const t of V.find(le))_e.getOrCreateInstance(t).show(); })), F.on(window, 'resize.bs.offcanvas', (() => { for (const t of V.find('[aria-modal][class*=show][class*=offcanvas-]'))getComputedStyle(t).position !== 'fixed' && _e.getOrCreateInstance(t).hide(); })), K(_e), b(_e); const ge = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']); const fe = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i; const me = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const pe = (t, e) => { const s = t.nodeName.toLowerCase(); return e.includes(s) ? !ge.has(s) || Boolean(fe.test(t.nodeValue) || me.test(t.nodeValue)) : e.filter(((t) => t instanceof RegExp)).some(((t) => t.test(s))); }; const be = {
    '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [],
  }; const ve = {
    allowList: be, content: {}, extraClass: '', html: !1, sanitize: !0, sanitizeFn: null, template: '<div></div>',
  }; const ye = {
    allowList: 'object', content: 'object', extraClass: '(string|function)', html: 'boolean', sanitize: 'boolean', sanitizeFn: '(null|function)', template: 'string',
  }; const we = { entry: '(string|element|function|null)', selector: '(string|element)' }; class Ae extends q {
    constructor(t) { super(), this._config = this._getConfig(t); }

    static get Default() { return ve; }

    static get DefaultType() { return ye; }

    static get NAME() { return 'TemplateFactory'; }

    getContent() { return Object.values(this._config.content).map(((t) => this._resolvePossibleFunction(t))).filter(Boolean); }

    hasContent() { return this.getContent().length > 0; }

    changeContent(t) { return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this; }

    toHtml() { const t = document.createElement('div'); t.innerHTML = this._maybeSanitize(this._config.template); for (const [e, s] of Object.entries(this._config.content)) this._setContent(t, s, e); const e = t.children[0]; const s = this._resolvePossibleFunction(this._config.extraClass); return s && e.classList.add(...s.split(' ')), e; }

    _typeCheckConfig(t) { super._typeCheckConfig(t), this._checkContent(t.content); }

    _checkContent(t) { for (const [e, s] of Object.entries(t)) super._typeCheckConfig({ selector: e, entry: s }, we); }

    _setContent(t, e, s) { const i = V.findOne(s, t); i && ((e = this._resolvePossibleFunction(e)) ? l(e) ? this._putElementInTemplate(c(e), i) : this._config.html ? i.innerHTML = this._maybeSanitize(e) : i.textContent = e : i.remove()); }

    _maybeSanitize(t) { return this._config.sanitize ? (function (t, e, s) { if (!t.length) return t; if (s && typeof s === 'function') return s(t); const i = (new window.DOMParser()).parseFromString(t, 'text/html'); const n = [].concat(...i.body.querySelectorAll('*')); for (const t of n) { const s = t.nodeName.toLowerCase(); if (!Object.keys(e).includes(s)) { t.remove(); continue; } const i = [].concat(...t.attributes); const n = [].concat(e['*'] || [], e[s] || []); for (const e of i)pe(e, n) || t.removeAttribute(e.nodeName); } return i.body.innerHTML; }(t, this._config.allowList, this._config.sanitizeFn)) : t; }

    _resolvePossibleFunction(t) { return v(t, [this]); }

    _putElementInTemplate(t, e) { if (this._config.html) return e.innerHTML = '', void e.append(t); e.textContent = t.textContent; }
  } const Ee = new Set(['sanitize', 'allowList', 'sanitizeFn']); const Ce = 'fade'; const Te = 'show'; const ke = '.modal'; const Se = 'hide.bs.modal'; const Le = 'hover'; const Oe = 'focus'; const Ie = {
    AUTO: 'auto', TOP: 'top', RIGHT: p() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: p() ? 'right' : 'left',
  }; const De = {
    allowList: be, animation: !0, boundary: 'clippingParents', container: !1, customClass: '', delay: 0, fallbackPlacements: ['top', 'right', 'bottom', 'left'], html: !1, offset: [0, 6], placement: 'top', popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: '', trigger: 'hover focus',
  }; const Ne = {
    allowList: 'object', animation: 'boolean', boundary: '(string|element)', container: '(string|element|boolean)', customClass: '(string|function)', delay: '(number|object)', fallbackPlacements: 'array', html: 'boolean', offset: '(array|string|function)', placement: '(string|function)', popperConfig: '(null|object|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', selector: '(string|boolean)', template: 'string', title: '(string|element|function)', trigger: 'string',
  }; class Pe extends W {
    constructor(t, e) { if (void 0 === s) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle(); }

    static get Default() { return De; }

    static get DefaultType() { return Ne; }

    static get NAME() { return 'tooltip'; }

    enable() { this._isEnabled = !0; }

    disable() { this._isEnabled = !1; }

    toggleEnabled() { this._isEnabled = !this._isEnabled; }

    toggle() { this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter()); }

    dispose() { clearTimeout(this._timeout), F.off(this._element.closest(ke), Se, this._hideModalHandler), this._element.getAttribute('data-bs-original-title') && this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title')), this._disposePopper(), super.dispose(); }

    show() { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!this._isWithContent() || !this._isEnabled) return; const t = F.trigger(this._element, this.constructor.eventName('show')); const e = (u(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (t.defaultPrevented || !e) return; this._disposePopper(); const s = this._getTipElement(); this._element.setAttribute('aria-describedby', s.getAttribute('id')); const { container: i } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (i.append(s), F.trigger(this._element, this.constructor.eventName('inserted'))), this._popper = this._createPopper(s), s.classList.add(Te), 'ontouchstart' in document.documentElement) for (const t of [].concat(...document.body.children))F.on(t, 'mouseover', _); this._queueCallback((() => { F.trigger(this._element, this.constructor.eventName('shown')), !1 === this._isHovered && this._leave(), this._isHovered = !1; }), this.tip, this._isAnimated()); }

    hide() { if (this._isShown() && !F.trigger(this._element, this.constructor.eventName('hide')).defaultPrevented) { if (this._getTipElement().classList.remove(Te), 'ontouchstart' in document.documentElement) for (const t of [].concat(...document.body.children))F.off(t, 'mouseover', _); this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this._isHovered = null, this._queueCallback((() => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute('aria-describedby'), F.trigger(this._element, this.constructor.eventName('hidden'))); }), this.tip, this._isAnimated()); } }

    update() { this._popper && this._popper.update(); }

    _isWithContent() { return Boolean(this._getTitle()); }

    _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip; }

    _createTipElement(t) { const e = this._getTemplateFactory(t).toHtml(); if (!e) return null; e.classList.remove(Ce, Te), e.classList.add(`bs-${this.constructor.NAME}-auto`); const s = ((t) => { do { t += Math.floor(1e6 * Math.random()); } while (document.getElementById(t)); return t; })(this.constructor.NAME).toString(); return e.setAttribute('id', s), this._isAnimated() && e.classList.add(Ce), e; }

    setContent(t) { this._newContent = t, this._isShown() && (this._disposePopper(), this.show()); }

    _getTemplateFactory(t) { return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Ae({ ...this._config, content: t, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory; }

    _getContentForTemplate() { return { '.tooltip-inner': this._getTitle() }; }

    _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title'); }

    _initializeOnDelegatedTarget(t) { return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()); }

    _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(Ce); }

    _isShown() { return this.tip && this.tip.classList.contains(Te); }

    _createPopper(t) { const e = v(this._config.placement, [this, t, this._element]); const i = Ie[e.toUpperCase()]; return s.createPopper(this._element, t, this._getPopperConfig(i)); }

    _getOffset() { const { offset: t } = this._config; return typeof t === 'string' ? t.split(',').map(((t) => Number.parseInt(t, 10))) : typeof t === 'function' ? (e) => t(e, this._element) : t; }

    _resolvePossibleFunction(t) { return v(t, [this._element]); }

    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, {
          name: 'preSetPlacement', enabled: !0, phase: 'beforeMain', fn: (t) => { this._getTipElement().setAttribute('data-popper-placement', t.state.placement); },
        }],
      }; return { ...e, ...v(this._config.popperConfig, [e]) };
    }

    _setListeners() { const t = this._config.trigger.split(' '); for (const e of t) if (e === 'click')F.on(this._element, this.constructor.eventName('click'), this._config.selector, ((t) => { this._initializeOnDelegatedTarget(t).toggle(); })); else if (e !== 'manual') { const t = e === Le ? this.constructor.eventName('mouseenter') : this.constructor.eventName('focusin'); const s = e === Le ? this.constructor.eventName('mouseleave') : this.constructor.eventName('focusout'); F.on(this._element, t, this._config.selector, ((t) => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger[t.type === 'focusin' ? Oe : Le] = !0, e._enter(); })), F.on(this._element, s, this._config.selector, ((t) => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger[t.type === 'focusout' ? Oe : Le] = e._element.contains(t.relatedTarget), e._leave(); })); } this._hideModalHandler = () => { this._element && this.hide(); }, F.on(this._element.closest(ke), Se, this._hideModalHandler); }

    _fixTitle() { const t = this._element.getAttribute('title'); t && (this._element.getAttribute('aria-label') || this._element.textContent.trim() || this._element.setAttribute('aria-label', t), this._element.setAttribute('data-bs-original-title', t), this._element.removeAttribute('title')); }

    _enter() { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => { this._isHovered && this.show(); }), this._config.delay.show)); }

    _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => { this._isHovered || this.hide(); }), this._config.delay.hide)); }

    _setTimeout(t, e) { clearTimeout(this._timeout), this._timeout = setTimeout(t, e); }

    _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0); }

    _getConfig(t) { const e = B.getDataAttributes(this._element); for (const t of Object.keys(e))Ee.has(t) && delete e[t]; return t = { ...e, ...typeof t === 'object' && t ? t : {} }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t; }

    _configAfterMerge(t) { return t.container = !1 === t.container ? document.body : c(t.container), typeof t.delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === 'number' && (t.title = t.title.toString()), typeof t.content === 'number' && (t.content = t.content.toString()), t; }

    _getDelegateConfig() { const t = {}; for (const [e, s] of Object.entries(this._config)) this.constructor.Default[e] !== s && (t[e] = s); return t.selector = !1, t.trigger = 'manual', t; }

    _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null); }

    static jQueryInterface(t) { return this.each((function () { const e = Pe.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }b(Pe); const xe = {
    ...Pe.Default, content: '', offset: [0, 8], placement: 'right', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: 'click',
  }; const Me = { ...Pe.DefaultType, content: '(null|string|element|function)' }; class je extends Pe {
    static get Default() { return xe; }

    static get DefaultType() { return Me; }

    static get NAME() { return 'popover'; }

    _isWithContent() { return this._getTitle() || this._getContent(); }

    _getContentForTemplate() { return { '.popover-header': this._getTitle(), '.popover-body': this._getContent() }; }

    _getContent() { return this._resolvePossibleFunction(this._config.content); }

    static jQueryInterface(t) { return this.each((function () { const e = je.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }b(je); const Fe = 'click.bs.scrollspy'; const $e = 'active'; const ze = '[href]'; const He = {
    offset: null, rootMargin: '0px 0px -25%', smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1],
  }; const Be = {
    offset: '(number|null)', rootMargin: 'string', smoothScroll: 'boolean', target: 'element', threshold: 'array',
  }; class qe extends W {
    constructor(t, e) { super(t, e), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh(); }

    static get Default() { return He; }

    static get DefaultType() { return Be; }

    static get NAME() { return 'scrollspy'; }

    refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t); }

    dispose() { this._observer.disconnect(), super.dispose(); }

    _configAfterMerge(t) { return t.target = c(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, typeof t.threshold === 'string' && (t.threshold = t.threshold.split(',').map(((t) => Number.parseFloat(t)))), t; }

    _maybeEnableSmoothScroll() { this._config.smoothScroll && (F.off(this._config.target, Fe), F.on(this._config.target, Fe, ze, ((t) => { const e = this._observableSections.get(t.target.hash); if (e) { t.preventDefault(); const s = this._rootElement || window; const i = e.offsetTop - this._element.offsetTop; if (s.scrollTo) return void s.scrollTo({ top: i, behavior: 'smooth' }); s.scrollTop = i; } }))); }

    _getNewObserver() { const t = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(((t) => this._observerCallback(t)), t); }

    _observerCallback(t) { const e = (t) => this._targetLinks.get(`#${t.target.id}`); const s = (t) => { this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t)); }; const i = (this._rootElement || document.documentElement).scrollTop; const n = i >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = i; for (const o of t) { if (!o.isIntersecting) { this._activeTarget = null, this._clearActiveClass(e(o)); continue; } const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (n && t) { if (s(o), !i) return; } else n || t || s(o); } }

    _initializeTargetsAndObservables() { this._targetLinks = new Map(), this._observableSections = new Map(); const t = V.find(ze, this._config.target); for (const e of t) { if (!e.hash || d(e)) continue; const t = V.findOne(e.hash, this._element); h(t) && (this._targetLinks.set(e.hash, e), this._observableSections.set(e.hash, t)); } }

    _process(t) { this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add($e), this._activateParents(t), F.trigger(this._element, 'activate.bs.scrollspy', { relatedTarget: t })); }

    _activateParents(t) { if (t.classList.contains('dropdown-item'))V.findOne('.dropdown-toggle', t.closest('.dropdown')).classList.add($e); else for (const e of V.parents(t, '.nav, .list-group')) for (const t of V.prev(e, '.nav-link, .nav-item > .nav-link, .list-group-item'))t.classList.add($e); }

    _clearActiveClass(t) { t.classList.remove($e); const e = V.find('[href].active', t); for (const t of e)t.classList.remove($e); }

    static jQueryInterface(t) { return this.each((function () { const e = qe.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t] || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }F.on(window, 'load.bs.scrollspy.data-api', (() => { for (const t of V.find('[data-bs-spy="scroll"]'))qe.getOrCreateInstance(t); })), b(qe); const We = 'ArrowLeft'; const Re = 'ArrowRight'; const Ve = 'ArrowUp'; const Ke = 'ArrowDown'; const Qe = 'active'; const Xe = 'fade'; const Ye = 'show'; const Ue = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; const Ge = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Ue}`; class Je extends W {
    constructor(t) { super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), F.on(this._element, 'keydown.bs.tab', ((t) => this._keydown(t)))); }

    static get NAME() { return 'tab'; }

    show() { const t = this._element; if (this._elemIsActive(t)) return; const e = this._getActiveElem(); const s = e ? F.trigger(e, 'hide.bs.tab', { relatedTarget: t }) : null; F.trigger(t, 'show.bs.tab', { relatedTarget: e }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(e, t), this._activate(t, e)); }

    _activate(t, e) { t && (t.classList.add(Qe), this._activate(V.getElementFromSelector(t)), this._queueCallback((() => { t.getAttribute('role') === 'tab' ? (t.removeAttribute('tabindex'), t.setAttribute('aria-selected', !0), this._toggleDropDown(t, !0), F.trigger(t, 'shown.bs.tab', { relatedTarget: e })) : t.classList.add(Ye); }), t, t.classList.contains(Xe))); }

    _deactivate(t, e) { t && (t.classList.remove(Qe), t.blur(), this._deactivate(V.getElementFromSelector(t)), this._queueCallback((() => { t.getAttribute('role') === 'tab' ? (t.setAttribute('aria-selected', !1), t.setAttribute('tabindex', '-1'), this._toggleDropDown(t, !1), F.trigger(t, 'hidden.bs.tab', { relatedTarget: e })) : t.classList.remove(Ye); }), t, t.classList.contains(Xe))); }

    _keydown(t) { if (![We, Re, Ve, Ke].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const e = [Re, Ke].includes(t.key); const s = w(this._getChildren().filter(((t) => !d(t))), t.target, e, !0); s && (s.focus({ preventScroll: !0 }), Je.getOrCreateInstance(s).show()); }

    _getChildren() { return V.find(Ge, this._parent); }

    _getActiveElem() { return this._getChildren().find(((t) => this._elemIsActive(t))) || null; }

    _setInitialAttributes(t, e) { this._setAttributeIfNotExists(t, 'role', 'tablist'); for (const t of e) this._setInitialAttributesOnChild(t); }

    _setInitialAttributesOnChild(t) { t = this._getInnerElement(t); const e = this._elemIsActive(t); const s = this._getOuterElement(t); t.setAttribute('aria-selected', e), s !== t && this._setAttributeIfNotExists(s, 'role', 'presentation'), e || t.setAttribute('tabindex', '-1'), this._setAttributeIfNotExists(t, 'role', 'tab'), this._setInitialAttributesOnTargetPanel(t); }

    _setInitialAttributesOnTargetPanel(t) { const e = V.getElementFromSelector(t); e && (this._setAttributeIfNotExists(e, 'role', 'tabpanel'), t.id && this._setAttributeIfNotExists(e, 'aria-labelledby', `${t.id}`)); }

    _toggleDropDown(t, e) { const s = this._getOuterElement(t); if (!s.classList.contains('dropdown')) return; const i = (t, i) => { const n = V.findOne(t, s); n && n.classList.toggle(i, e); }; i('.dropdown-toggle', Qe), i('.dropdown-menu', Ye), s.setAttribute('aria-expanded', e); }

    _setAttributeIfNotExists(t, e, s) { t.hasAttribute(e) || t.setAttribute(e, s); }

    _elemIsActive(t) { return t.classList.contains(Qe); }

    _getInnerElement(t) { return t.matches(Ge) ? t : V.findOne(Ge, t); }

    _getOuterElement(t) { return t.closest('.nav-item, .list-group-item') || t; }

    static jQueryInterface(t) { return this.each((function () { const e = Je.getOrCreateInstance(this); if (typeof t === 'string') { if (void 0 === e[t] || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }F.on(document, 'click.bs.tab', Ue, (function (t) { ['A', 'AREA'].includes(this.tagName) && t.preventDefault(), d(this) || Je.getOrCreateInstance(this).show(); })), F.on(window, 'load.bs.tab', (() => { for (const t of V.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'))Je.getOrCreateInstance(t); })), b(Je); const Ze = 'hide'; const ts = 'show'; const es = 'showing'; const ss = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const is = { animation: !0, autohide: !0, delay: 5e3 }; class ns extends W {
    constructor(t, e) { super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(); }

    static get Default() { return is; }

    static get DefaultType() { return ss; }

    static get NAME() { return 'toast'; }

    show() { F.trigger(this._element, 'show.bs.toast').defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add('fade'), this._element.classList.remove(Ze), g(this._element), this._element.classList.add(ts, es), this._queueCallback((() => { this._element.classList.remove(es), F.trigger(this._element, 'shown.bs.toast'), this._maybeScheduleHide(); }), this._element, this._config.animation)); }

    hide() { this.isShown() && (F.trigger(this._element, 'hide.bs.toast').defaultPrevented || (this._element.classList.add(es), this._queueCallback((() => { this._element.classList.add(Ze), this._element.classList.remove(es, ts), F.trigger(this._element, 'hidden.bs.toast'); }), this._element, this._config.animation))); }

    dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(ts), super.dispose(); }

    isShown() { return this._element.classList.contains(ts); }

    _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide(); }), this._config.delay))); }

    _onInteraction(t, e) { switch (t.type) { case 'mouseover': case 'mouseout': this._hasMouseInteraction = e; break; case 'focusin': case 'focusout': this._hasKeyboardInteraction = e; } if (e) return void this._clearTimeout(); const s = t.relatedTarget; this._element === s || this._element.contains(s) || this._maybeScheduleHide(); }

    _setListeners() { F.on(this._element, 'mouseover.bs.toast', ((t) => this._onInteraction(t, !0))), F.on(this._element, 'mouseout.bs.toast', ((t) => this._onInteraction(t, !1))), F.on(this._element, 'focusin.bs.toast', ((t) => this._onInteraction(t, !0))), F.on(this._element, 'focusout.bs.toast', ((t) => this._onInteraction(t, !1))); }

    _clearTimeout() { clearTimeout(this._timeout), this._timeout = null; }

    static jQueryInterface(t) { return this.each((function () { const e = ns.getOrCreateInstance(this, t); if (typeof t === 'string') { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  } return K(ns), b(ns), {
    Alert: Q, Button: Y, Carousel: ct, Collapse: mt, Dropdown: xt, Modal: ne, Offcanvas: _e, Popover: je, ScrollSpy: qe, Tab: Je, Toast: ns, Tooltip: Pe,
  };
})));
// # sourceMappingURL=bootstrap.min.js.map